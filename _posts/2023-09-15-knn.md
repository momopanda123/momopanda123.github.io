---
layout: default
title: 09. KNN
subtitle: 지능자동화실제 과목
---
-----

[PINBlog Gitea Repository](https://gitea.pinblog.codes/CBNU/09_KNN)

-----

# Feature Matching
- 산업인공지능학과 대학원
    2022254026
        김홍열


---


# **K-Nearest Neighbors (KNN)**
### **가장 가까운 이웃을 통한 예측**

오늘은 기계 학습의 간단하면서도 강력한 알고리즘인 K-Nearest Neighbors (KNN)에 대해 알아보려고 합니다. 
KNN은 분류와 회귀 문제 모두에 사용될 수 있습니다.


# **1. KNN이란 무엇인가?**

KNN은 지도 학습 알고리즘 중 하나로, 주어진 데이터 포인트의 가장 가까운 이웃을 찾아 예측을 수행하는 방법입니다. 
이름에서 알 수 있듯이, 'K'는 고려할 이웃의 수를 나타냅니다.


# **2. 어떻게 작동하는가?**

KNN의 작동 원리는 매우 간단합니다.

    - 1. 새로운 데이터 포인트가 주어지면, 전체 데이터 세트에서 해당 포인트와 가장 가까운 'K'개의 이웃을 찾습니다.
    - 2. 분류 문제의 경우, K 이웃 중 가장 많은 클래스를 새로운 데이터 포인트의 클래스로 예측합니다.
    - 3. 회귀 문제의 경우, K 이웃의 평균 값을 새로운 데이터 포인트의 값으로 예측합니다.


# **3. 거리 측정**

KNN에서 가장 중요한 부분은 '거리'를 어떻게 측정하는지입니다. 
일반적으로 유클리디안 거리가 사용되지만, 맨하탄 거리나 코사인 유사도 등 다른 방법도 사용될 수 있습니다.


# **4. KNN의 장점**

- **간단하고 직관적**: KNN은 알고리즘의 원리가 간단하며, 파라미터 튜닝이 최소화됩니다.
- **비모수적 방법**: 데이터의 분포에 대한 가정이 필요 없습니다.
- **다목적 사용**: 분류와 회귀 모두에 사용될 수 있습니다.


# **5. 사용 사례**

KNN은 기계 학습의 기본적인 알고리즘 중 하나로 추천 시스템, 이미지 인식, 텍스트 분류 등 다양한 분야에서 사용됩니다.
그 간결함과 유용함으로 인해 많은 연구자와 개발자에게 사랑받고 있습니다.
다음 번에는 KNN을 실제로 구현하고 실행하는 방법에 대해 알아보겠습니다!


---

### 예제 코드[¶]()

<details>
<summary>KNN - Plane</summary>

<details>
<summary>Main Func</summary>
<div markdown="1">
  
```c++

void kNN()
{
	img = Mat::zeros(Size(500, 500), CV_8UC3);
	knn = KNearest::create();

	namedWindow("knn");
	//createTrackbar("k", "knn", &k_value, 5, on_k_changed);

	const int NUM = 30;
	Mat rn(NUM, 2, CV_32SC1);

	randn(rn, 0, 50);
	for (int i = 0; i < NUM; i++)
		addPoint(Point(rn.at<int>(i, 0) + 150, rn.at<int>(i, 1) + 150), 0);

	randn(rn, 0, 50);
	for (int i = 0; i < NUM; i++)
		addPoint(Point(rn.at<int>(i, 0) + 350, rn.at<int>(i, 1) + 150), 1);

	randn(rn, 0, 70);
	for (int i = 0; i < NUM; i++)
		addPoint(Point(rn.at<int>(i, 0) + 250, rn.at<int>(i, 1) + 400), 2);

	createTrackbar("k", "knn", &k_value, 5, on_k_changed);
	trainAndDisplay();
	waitKey();

	return;
}

```

</div>
</details>

<details>
<summary>Key Event</summary>
<div markdown="1">
  
```c++

void on_k_changed(int, void*)
{
	if (k_value < 1) k_value = 1;
	trainAndDisplay();
}

```

</div>
</details>

<details>
<summary>Add Point Func</summary>
<div markdown="1">
  
```c++

void addPoint(const Point& pt, int cls)
{
	Mat new_sample = (Mat_<float>(1, 2) << pt.x, pt.y);
	train.push_back(new_sample);

	Mat new_label = (Mat_<int>(1, 1) << cls);
	label.push_back(new_label);
}

```

</div>
</details>

<details>
<summary>Display Func</summary>
<div markdown="1">
  
```c++

void trainAndDisplay()
{
	knn->train(train, ROW_SAMPLE, label);
	for (int i = 0; i < img.rows; ++i) {
		for (int j = 0; j < img.cols; ++j) {
			Mat sample = (Mat_<float>(1, 2) << j, i);
			Mat res;
			knn->findNearest(sample, k_value, res);
			int response = cvRound(res.at<float>(0, 0));
			if (response == 0)
				img.at<Vec3b>(i, j) = Vec3b(128, 128, 255);  // R
			else if (response == 1)
				img.at<Vec3b>(i, j) = Vec3b(128, 255, 128); // G
			else if (response == 2)
				img.at<Vec3b >(i, j) = Vec3b(255, 128, 128);  // B
		}
	}

	for (int i = 0; i < train.rows; i++)
	{
		int x = cvRound(train.at<float>(i, 0));
		int y = cvRound(train.at<float>(i, 1));
		int l = label.at<int>(i, 0);

		if (l == 0)
			circle(img, Point(x, y), 5, Scalar(0, 0, 128), -1, LINE_AA);
		else if (1 == 1)
			circle(img, Point(x, y), 5, Scalar(0, 128, 0), -1, LINE_AA);
		else if (1 == 2)
			circle(img, Point(x, y), 5, Scalar(128, 0, 0), -1, LINE_AA);
	}

	imshow("knn", img);
	imwrite("knn-result1.png", img);
}

```

</div>
</details>

![Result](/assets/img/knn-result1.png)

</details>


<details>
<summary>KNN - Digits</summary>

<details>
<summary>Train</summary>
<div markdown="1">
  
```c++

Ptr<KNearest> train_knn()
{
	Mat digits = imread("digits.png", IMREAD_GRAYSCALE);
	if (digits.empty())
	{
		cerr << "Image load failed!" << endl;
		return 0;
	}

	Mat train_images, train_labels;

	for (int j = 0; j < 50; j++)
	{
		for (int i = 0; i < 100; i++)
		{
			Mat roi, roi_float, roi_flatten;
			roi = digits(Rect(i * 20, j * 20, 20, 20));
			roi.convertTo(roi_float, CV_32F);
			roi_flatten = roi_float.reshape(1, 1);

			train_images.push_back(roi_flatten);
			train_labels.push_back(j / 5);
		}
	}

	Ptr<KNearest> knn = KNearest::create();
	knn->train(train_images, ROW_SAMPLE, train_labels);

	return knn;
}

```

</div>
</details>

<details>
<summary>Mouse Event</summary>
<div markdown="1">
  
```c++

Point ptPrev(-1, -1);
void on_mouse(int event, int x, int y, int flags, void* userdata)
{
	Mat img = *(Mat*)userdata;

	if (event == EVENT_LBUTTONDOWN)
	{
		ptPrev = Point(x, y);
	}
	else if (event == EVENT_LBUTTONUP)
	{
		ptPrev = Point(-1, -1);
	}
	else if (event == EVENT_MOUSEMOVE && (flags & EVENT_FLAG_LBUTTON))
	{
		line(img, ptPrev, Point(x, y), Scalar::all(255), 40, LINE_AA, 0);
		ptPrev = Point(x, y);
		imshow("img", img);
	}
}

```

</div>
</details>

<details>
<summary>Main Func</summary>
<div markdown="1">
  
```c++

int knn_digits()
{
	Ptr<KNearest> knn = train_knn();

	if (knn.empty())
	{
		cerr << "Training failed!" << endl;
		return -1;
	}

	Mat img = Mat::zeros(400, 400, CV_8U);
	imshow("img", img);
	setMouseCallback("img", on_mouse, (void*)&img);

	while (true)
	{
		int c = waitKey(0);
		if (c == 27)
			break;
		else if (c == ' ')
		{
			Mat img_resize, img_float, img_flatten, res;

			resize(img, img_resize, Size(20, 20), 0, 0, INTER_AREA);
			img_resize.convertTo(img_float, CV_32F);
			img_flatten = img_float.reshape(1, 1);

			knn->findNearest(img_flatten, 3, res);
			cout << cvRound(res.at<float>(0, 0)) << endl;

			img.setTo(0);
			imshow("img", img);
			imwrite("knn-result2.png", img);
		}
	}

	return 0;
}

```

</div>
</details>

![Origin](/assets/img/digits.png)
![Result](/assets/img/knn-result2.png)
![Result](/assets/img/knn-result3.png)

</details>


# **6. 결론**

이렇게 KNN에 대한 기본적인 개념과 특징을 간단하게 소개하는 블로그 포스트를 작성해 보았습니다. 
다음 포스트에서는 실제 코드 예제와 함께 KNN의 실제 응용 사례를 살펴보는 것도 좋을 것 같습니다!


---

### 참고[¶]()

- 지능자동화실제 과목, 박태형 교수
- ChatGPT
